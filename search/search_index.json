{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pydantic Argparse Typed Argument Parsing with Pydantic Overview pydantic-argparse is a Python package built on top of pydantic which provides declarative typed argument parsing using pydantic models. Requirements pydantic-argparse requires Python 3.9+ Installation Installation with pip is simple: $ pip install pydantic-argparse Quick Start Define Model simple.py \"\"\"Simple Example\"\"\" # Third-Party import pydantic import pydantic_argparse class Arguments ( pydantic . BaseModel ): \"\"\"Simple Command-Line Arguments\"\"\" # Required Args string : str = pydantic . Field ( description = \"a required string\" ) integer : int = pydantic . Field ( description = \"a required integer\" ) flag : bool = pydantic . Field ( description = \"a required flag\" ) # Optional Args second_flag : bool = pydantic . Field ( False , description = \"an optional flag\" ) third_flag : bool = pydantic . Field ( True , description = \"an optional flag\" ) def main () -> None : \"\"\"Simple Main Function\"\"\" # Create Parser and Parse Args parser = pydantic_argparse . ArgumentParser ( model = Arguments , prog = \"Example Program\" , description = \"Example Description\" , version = \"0.0.1\" , epilog = \"Example Epilog\" , ) args = parser . parse_typed_args () # Print Args print ( args ) if __name__ == \"__main__\" : main () Check Help $ python3 simple.py --help usage: Example Program [-h] [-v] --string STRING --integer INTEGER --flag | --no-flag [--second-flag] [--no-third-flag] Example Description required arguments: --string STRING a required string --integer INTEGER a required integer --flag, --no-flag a required flag optional arguments: --second-flag an optional flag (default: False) --no-third-flag an optional flag (default: True) help: -h, --help show this help message and exit -v, --version show program's version number and exit Example Epilog Parse Arguments $ python3 simple.py --string hello --integer 42 --flag string='hello' integer=42 flag=True second_flag=False third_flag=True Credits This project is made possible by the following projects: pydantic typing-inspect License This project is licensed under the terms of the MIT license.","title":"Overview"},{"location":"#overview","text":"pydantic-argparse is a Python package built on top of pydantic which provides declarative typed argument parsing using pydantic models.","title":"Overview"},{"location":"#requirements","text":"pydantic-argparse requires Python 3.9+","title":"Requirements"},{"location":"#installation","text":"Installation with pip is simple: $ pip install pydantic-argparse","title":"Installation"},{"location":"#quick-start","text":"","title":"Quick Start"},{"location":"#define-model","text":"simple.py \"\"\"Simple Example\"\"\" # Third-Party import pydantic import pydantic_argparse class Arguments ( pydantic . BaseModel ): \"\"\"Simple Command-Line Arguments\"\"\" # Required Args string : str = pydantic . Field ( description = \"a required string\" ) integer : int = pydantic . Field ( description = \"a required integer\" ) flag : bool = pydantic . Field ( description = \"a required flag\" ) # Optional Args second_flag : bool = pydantic . Field ( False , description = \"an optional flag\" ) third_flag : bool = pydantic . Field ( True , description = \"an optional flag\" ) def main () -> None : \"\"\"Simple Main Function\"\"\" # Create Parser and Parse Args parser = pydantic_argparse . ArgumentParser ( model = Arguments , prog = \"Example Program\" , description = \"Example Description\" , version = \"0.0.1\" , epilog = \"Example Epilog\" , ) args = parser . parse_typed_args () # Print Args print ( args ) if __name__ == \"__main__\" : main ()","title":"Define Model"},{"location":"#check-help","text":"$ python3 simple.py --help usage: Example Program [-h] [-v] --string STRING --integer INTEGER --flag | --no-flag [--second-flag] [--no-third-flag] Example Description required arguments: --string STRING a required string --integer INTEGER a required integer --flag, --no-flag a required flag optional arguments: --second-flag an optional flag (default: False) --no-third-flag an optional flag (default: True) help: -h, --help show this help message and exit -v, --version show program's version number and exit Example Epilog","title":"Check Help"},{"location":"#parse-arguments","text":"$ python3 simple.py --string hello --integer 42 --flag string='hello' integer=42 flag=True second_flag=False third_flag=True","title":"Parse Arguments"},{"location":"#credits","text":"This project is made possible by the following projects: pydantic typing-inspect","title":"Credits"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"examples/commands/","text":"Define Model commands.py \"\"\"Commands Example\"\"\" # Third-Party import pydantic import pydantic_argparse # Typing from typing import Optional # pylint: disable=wrong-import-order class BuildCommand ( pydantic . BaseModel ): \"\"\"Build Command Arguments\"\"\" # Required Args location : pydantic . FilePath = pydantic . Field ( description = \"build location\" ) class ServeCommand ( pydantic . BaseModel ): \"\"\"Serve Command Arguments\"\"\" # Required Args address : pydantic . IPvAnyAddress = pydantic . Field ( description = \"serve address\" ) port : int = pydantic . Field ( description = \"serve port\" ) class Arguments ( pydantic . BaseModel ): \"\"\"Command-Line Arguments\"\"\" # Optional Args verbose : bool = pydantic . Field ( False , description = \"verbose flag\" ) # Commands build : Optional [ BuildCommand ] = pydantic . Field ( description = \"build command\" ) serve : Optional [ ServeCommand ] = pydantic . Field ( description = \"serve command\" ) def main () -> None : \"\"\"Main Function\"\"\" # Create Parser and Parse Args parser = pydantic_argparse . ArgumentParser ( model = Arguments , prog = \"Example Program\" , description = \"Example Description\" , version = \"0.0.1\" , epilog = \"Example Epilog\" , ) args = parser . parse_typed_args () # Print Args print ( args ) if __name__ == \"__main__\" : main () Check Help $ python3 examples/commands.py --help usage: Example Program [-h] [-v] [--verbose] {build,serve} ... Example Description commands: {build,serve} build build command serve serve command optional arguments: --verbose verbose flag (default: False) help: -h, --help show this help message and exit -v, --version show program's version number and exit Example Epilog Check Commands Help $ python3 examples/commands.py serve --help usage: Example Program serve [-h] --address ADDRESS --port PORT required arguments: --address ADDRESS serve address --port PORT serve port help: -h, --help show this help message and exit Parse Arguments $ python3 examples/commands.py --verbose serve --address 127 .0.0.1 --port 8080 verbose=True build=None serve=ServeCommand(address=IPv4Address('127.0.0.1'), port=8080)","title":"Commands"},{"location":"examples/commands/#define-model","text":"commands.py \"\"\"Commands Example\"\"\" # Third-Party import pydantic import pydantic_argparse # Typing from typing import Optional # pylint: disable=wrong-import-order class BuildCommand ( pydantic . BaseModel ): \"\"\"Build Command Arguments\"\"\" # Required Args location : pydantic . FilePath = pydantic . Field ( description = \"build location\" ) class ServeCommand ( pydantic . BaseModel ): \"\"\"Serve Command Arguments\"\"\" # Required Args address : pydantic . IPvAnyAddress = pydantic . Field ( description = \"serve address\" ) port : int = pydantic . Field ( description = \"serve port\" ) class Arguments ( pydantic . BaseModel ): \"\"\"Command-Line Arguments\"\"\" # Optional Args verbose : bool = pydantic . Field ( False , description = \"verbose flag\" ) # Commands build : Optional [ BuildCommand ] = pydantic . Field ( description = \"build command\" ) serve : Optional [ ServeCommand ] = pydantic . Field ( description = \"serve command\" ) def main () -> None : \"\"\"Main Function\"\"\" # Create Parser and Parse Args parser = pydantic_argparse . ArgumentParser ( model = Arguments , prog = \"Example Program\" , description = \"Example Description\" , version = \"0.0.1\" , epilog = \"Example Epilog\" , ) args = parser . parse_typed_args () # Print Args print ( args ) if __name__ == \"__main__\" : main ()","title":"Define Model"},{"location":"examples/commands/#check-help","text":"$ python3 examples/commands.py --help usage: Example Program [-h] [-v] [--verbose] {build,serve} ... Example Description commands: {build,serve} build build command serve serve command optional arguments: --verbose verbose flag (default: False) help: -h, --help show this help message and exit -v, --version show program's version number and exit Example Epilog","title":"Check Help"},{"location":"examples/commands/#check-commands-help","text":"$ python3 examples/commands.py serve --help usage: Example Program serve [-h] --address ADDRESS --port PORT required arguments: --address ADDRESS serve address --port PORT serve port help: -h, --help show this help message and exit","title":"Check Commands Help"},{"location":"examples/commands/#parse-arguments","text":"$ python3 examples/commands.py --verbose serve --address 127 .0.0.1 --port 8080 verbose=True build=None serve=ServeCommand(address=IPv4Address('127.0.0.1'), port=8080)","title":"Parse Arguments"},{"location":"examples/simple/","text":"Define Model simple.py \"\"\"Simple Example\"\"\" # Third-Party import pydantic import pydantic_argparse class Arguments ( pydantic . BaseModel ): \"\"\"Simple Command-Line Arguments\"\"\" # Required Args string : str = pydantic . Field ( description = \"a required string\" ) integer : int = pydantic . Field ( description = \"a required integer\" ) flag : bool = pydantic . Field ( description = \"a required flag\" ) # Optional Args second_flag : bool = pydantic . Field ( False , description = \"an optional flag\" ) third_flag : bool = pydantic . Field ( True , description = \"an optional flag\" ) def main () -> None : \"\"\"Simple Main Function\"\"\" # Create Parser and Parse Args parser = pydantic_argparse . ArgumentParser ( model = Arguments , prog = \"Example Program\" , description = \"Example Description\" , version = \"0.0.1\" , epilog = \"Example Epilog\" , ) args = parser . parse_typed_args () # Print Args print ( args ) if __name__ == \"__main__\" : main () Check Help $ python3 simple.py --help usage: Example Program [-h] [-v] --string STRING --integer INTEGER --flag | --no-flag [--second-flag] [--no-third-flag] Example Description required arguments: --string STRING a required string --integer INTEGER a required integer --flag, --no-flag a required flag optional arguments: --second-flag an optional flag (default: False) --no-third-flag an optional flag (default: True) help: -h, --help show this help message and exit -v, --version show program's version number and exit Example Epilog Parse Arguments $ python3 simple.py --string hello --integer 42 --flag string='hello' integer=42 flag=True second_flag=False third_flag=True","title":"Simple"},{"location":"examples/simple/#define-model","text":"simple.py \"\"\"Simple Example\"\"\" # Third-Party import pydantic import pydantic_argparse class Arguments ( pydantic . BaseModel ): \"\"\"Simple Command-Line Arguments\"\"\" # Required Args string : str = pydantic . Field ( description = \"a required string\" ) integer : int = pydantic . Field ( description = \"a required integer\" ) flag : bool = pydantic . Field ( description = \"a required flag\" ) # Optional Args second_flag : bool = pydantic . Field ( False , description = \"an optional flag\" ) third_flag : bool = pydantic . Field ( True , description = \"an optional flag\" ) def main () -> None : \"\"\"Simple Main Function\"\"\" # Create Parser and Parse Args parser = pydantic_argparse . ArgumentParser ( model = Arguments , prog = \"Example Program\" , description = \"Example Description\" , version = \"0.0.1\" , epilog = \"Example Epilog\" , ) args = parser . parse_typed_args () # Print Args print ( args ) if __name__ == \"__main__\" : main ()","title":"Define Model"},{"location":"examples/simple/#check-help","text":"$ python3 simple.py --help usage: Example Program [-h] [-v] --string STRING --integer INTEGER --flag | --no-flag [--second-flag] [--no-third-flag] Example Description required arguments: --string STRING a required string --integer INTEGER a required integer --flag, --no-flag a required flag optional arguments: --second-flag an optional flag (default: False) --no-third-flag an optional flag (default: True) help: -h, --help show this help message and exit -v, --version show program's version number and exit Example Epilog","title":"Check Help"},{"location":"examples/simple/#parse-arguments","text":"$ python3 simple.py --string hello --integer 42 --flag string='hello' integer=42 flag=True second_flag=False third_flag=True","title":"Parse Arguments"},{"location":"reference/SUMMARY/","text":"pydantic_argparse argparse actions.py parser.py parsers boolean.py command.py container.py enum.py json.py literal.py standard.py utils utils.py","title":"SUMMARY"},{"location":"reference/pydantic_argparse/","text":"pydantic_argparse __init__.py Declarative Typed Argument Parsing with Pydantic Models This is the pydantic-argparse package, which contains the classes, methods and functions required for declarative and typed argument parsing with pydantic models. The public interface exposed by this package is the declarative and typed ArgumentParser class, as well as the package \"dunder\" metadata. __version__.py Single-Source of Truth Package Versioning and Metadata The pydantic-argparse package uses the pyproject.toml file as a single-source of truth for the package metadata. As such, rather than duplicating the metadata in code here, it is retrieved from the installed package metadata at runtime. The metadata exported are the title , description , version , author and license of the package","title":"pydantic_argparse"},{"location":"reference/pydantic_argparse/#pydantic_argparse","text":"","title":"pydantic_argparse"},{"location":"reference/pydantic_argparse/#__init__py","text":"Declarative Typed Argument Parsing with Pydantic Models This is the pydantic-argparse package, which contains the classes, methods and functions required for declarative and typed argument parsing with pydantic models. The public interface exposed by this package is the declarative and typed ArgumentParser class, as well as the package \"dunder\" metadata.","title":"__init__.py"},{"location":"reference/pydantic_argparse/#__version__py","text":"Single-Source of Truth Package Versioning and Metadata The pydantic-argparse package uses the pyproject.toml file as a single-source of truth for the package metadata. As such, rather than duplicating the metadata in code here, it is retrieved from the installed package metadata at runtime. The metadata exported are the title , description , version , author and license of the package","title":"__version__.py"},{"location":"reference/pydantic_argparse/argparse/","text":"argparse __init__.py Declarative and Typed Argument Parsing. This package contains the classes and methods required for declarative and typed argument parsing. The public interface exposed by this package is the ArgumentParser class, which is intended to be a near drop-in replacement for the Python standard library argparse.ArgumentParser - while providing declarative and typed argument parsing.","title":"argparse"},{"location":"reference/pydantic_argparse/argparse/#argparse","text":"","title":"argparse"},{"location":"reference/pydantic_argparse/argparse/#__init__py","text":"Declarative and Typed Argument Parsing. This package contains the classes and methods required for declarative and typed argument parsing. The public interface exposed by this package is the ArgumentParser class, which is intended to be a near drop-in replacement for the Python standard library argparse.ArgumentParser - while providing declarative and typed argument parsing.","title":"__init__.py"},{"location":"reference/pydantic_argparse/argparse/actions/","text":"actions Recursively Nesting Sub-Parsers Action for Typed Argument Parsing The actions module contains the SubParsersAction class, which is an action that provides recursive namespace nesting when parsing sub-commands. SubParsersAction Recursively Nesting Sub-Parsers Action for Typed Argument Parsing This custom action differs in functionality from the existing standard argparse SubParsersAction because it nests the resultant sub-namespace directly into the supplied parent namespace, rather than iterating through and updating the parent namespace object with each argument individually. Examples: Construct ArgumentParser : # Create Argument Parser parser = argparse . ArgumentParser () # Add Example Global Argument parser . add_argument ( \"--time\" ) # Add SubParsersAction subparsers = parser . add_subparsers () # Add Example 'walk' Command with Arguments walk = subparsers . add_parser ( \"walk\" ) walk . add_argument ( \"--speed\" ) walk . add_argument ( \"--distance\" ) # Add Example 'talk' Command with Arguments talk = subparsers . add_parser ( \"talk\" ) talk . add_argument ( \"--volume\" ) talk . add_argument ( \"--topic\" ) Parse the Arguments: --time 3 walk --speed 7 --distance 42 Check Resultant Namespaces: Original : Namespace ( time = 3 , speed = 7 , distance = 42 ) Custom : Namespace ( time = 3 , walk = Namespace ( speed = 7 , distance = 42 )) This behaviour results in a final namespace structure which is much easier to parse, where subcommands are easily identified and nested into their own namespace recursively. Source code in pydantic_argparse/argparse/actions.py class SubParsersAction ( argparse . _SubParsersAction ): # pylint: disable=protected-access \"\"\"Recursively Nesting Sub-Parsers Action for Typed Argument Parsing This custom action differs in functionality from the existing standard argparse SubParsersAction because it nests the resultant sub-namespace directly into the supplied parent namespace, rather than iterating through and updating the parent namespace object with each argument individually. Example: Construct `ArgumentParser`: ```python # Create Argument Parser parser = argparse.ArgumentParser() # Add Example Global Argument parser.add_argument(\"--time\") # Add SubParsersAction subparsers = parser.add_subparsers() # Add Example 'walk' Command with Arguments walk = subparsers.add_parser(\"walk\") walk.add_argument(\"--speed\") walk.add_argument(\"--distance\") # Add Example 'talk' Command with Arguments talk = subparsers.add_parser(\"talk\") talk.add_argument(\"--volume\") talk.add_argument(\"--topic\") ``` Parse the Arguments: ```console --time 3 walk --speed 7 --distance 42 ``` Check Resultant Namespaces: ```python Original: Namespace(time=3, speed=7, distance=42) Custom: Namespace(time=3, walk=Namespace(speed=7, distance=42)) ``` This behaviour results in a final namespace structure which is much easier to parse, where subcommands are easily identified and nested into their own namespace recursively. \"\"\" def __call__ ( self , parser : argparse . ArgumentParser , namespace : argparse . Namespace , values : Union [ str , Sequence [ Any ], None ], option_string : Optional [ str ] = None , ) -> None : \"\"\"Parses arguments with the specified subparser, then embeds the resultant sub-namespace into the supplied parent namespace. Args: parser (argparse.ArgumentParser): Parent argument parser object. namespace (argparse.Namespace): Parent namespace being parsed to. values (Union[str, Sequence[Any], None]): Arguments to parse. option_string (Optional[str]): Optional option string (not used). Raises: argparse.ArgumentError: Raised if subparser name does not exist. \"\"\" # Check values object is a sequence # In order to not violate the Liskov Substitution Principle (LSP), the # function signature for __call__ must match the base Action class. As # such, this function signature also accepts 'str' and 'None' types for # the values argument. However, in reality, this should only ever be a # list of strings here, so we just do a type cast. values = cast ( list [ str ], values ) # Get Parser Name and Remaining Argument Strings parser_name , * arg_strings = values # Try select the parser try : # Select the parser parser = self . _name_parser_map [ parser_name ] except KeyError as exc : # Parser doesn't exist, raise an exception raise argparse . ArgumentError ( self , f \"unknown parser { parser_name } (choices: { ', ' . join ( self . _name_parser_map ) } )\" ) from exc # Parse all the remaining options into a sub-namespace, then embed this # sub-namespace into the parent namespace subnamespace , arg_strings = parser . parse_known_args ( arg_strings ) setattr ( namespace , parser_name , subnamespace ) # Store any unrecognized options on the parent namespace, so that the # top level parser can decide what to do with them if arg_strings : vars ( namespace ) . setdefault ( argparse . _UNRECOGNIZED_ARGS_ATTR , []) getattr ( namespace , argparse . _UNRECOGNIZED_ARGS_ATTR ) . extend ( arg_strings ) __call__ ( self , parser , namespace , values , option_string = None ) special Parses arguments with the specified subparser, then embeds the resultant sub-namespace into the supplied parent namespace. Parameters: Name Type Description Default parser argparse.ArgumentParser Parent argument parser object. required namespace argparse.Namespace Parent namespace being parsed to. required values Union[str, Sequence[Any], None] Arguments to parse. required option_string Optional[str] Optional option string (not used). None Exceptions: Type Description argparse.ArgumentError Raised if subparser name does not exist. Source code in pydantic_argparse/argparse/actions.py def __call__ ( self , parser : argparse . ArgumentParser , namespace : argparse . Namespace , values : Union [ str , Sequence [ Any ], None ], option_string : Optional [ str ] = None , ) -> None : \"\"\"Parses arguments with the specified subparser, then embeds the resultant sub-namespace into the supplied parent namespace. Args: parser (argparse.ArgumentParser): Parent argument parser object. namespace (argparse.Namespace): Parent namespace being parsed to. values (Union[str, Sequence[Any], None]): Arguments to parse. option_string (Optional[str]): Optional option string (not used). Raises: argparse.ArgumentError: Raised if subparser name does not exist. \"\"\" # Check values object is a sequence # In order to not violate the Liskov Substitution Principle (LSP), the # function signature for __call__ must match the base Action class. As # such, this function signature also accepts 'str' and 'None' types for # the values argument. However, in reality, this should only ever be a # list of strings here, so we just do a type cast. values = cast ( list [ str ], values ) # Get Parser Name and Remaining Argument Strings parser_name , * arg_strings = values # Try select the parser try : # Select the parser parser = self . _name_parser_map [ parser_name ] except KeyError as exc : # Parser doesn't exist, raise an exception raise argparse . ArgumentError ( self , f \"unknown parser { parser_name } (choices: { ', ' . join ( self . _name_parser_map ) } )\" ) from exc # Parse all the remaining options into a sub-namespace, then embed this # sub-namespace into the parent namespace subnamespace , arg_strings = parser . parse_known_args ( arg_strings ) setattr ( namespace , parser_name , subnamespace ) # Store any unrecognized options on the parent namespace, so that the # top level parser can decide what to do with them if arg_strings : vars ( namespace ) . setdefault ( argparse . _UNRECOGNIZED_ARGS_ATTR , []) getattr ( namespace , argparse . _UNRECOGNIZED_ARGS_ATTR ) . extend ( arg_strings )","title":"actions.py"},{"location":"reference/pydantic_argparse/argparse/actions/#actions","text":"Recursively Nesting Sub-Parsers Action for Typed Argument Parsing The actions module contains the SubParsersAction class, which is an action that provides recursive namespace nesting when parsing sub-commands.","title":"actions"},{"location":"reference/pydantic_argparse/argparse/actions/#pydantic_argparse.argparse.actions.SubParsersAction","text":"Recursively Nesting Sub-Parsers Action for Typed Argument Parsing This custom action differs in functionality from the existing standard argparse SubParsersAction because it nests the resultant sub-namespace directly into the supplied parent namespace, rather than iterating through and updating the parent namespace object with each argument individually. Examples: Construct ArgumentParser : # Create Argument Parser parser = argparse . ArgumentParser () # Add Example Global Argument parser . add_argument ( \"--time\" ) # Add SubParsersAction subparsers = parser . add_subparsers () # Add Example 'walk' Command with Arguments walk = subparsers . add_parser ( \"walk\" ) walk . add_argument ( \"--speed\" ) walk . add_argument ( \"--distance\" ) # Add Example 'talk' Command with Arguments talk = subparsers . add_parser ( \"talk\" ) talk . add_argument ( \"--volume\" ) talk . add_argument ( \"--topic\" ) Parse the Arguments: --time 3 walk --speed 7 --distance 42 Check Resultant Namespaces: Original : Namespace ( time = 3 , speed = 7 , distance = 42 ) Custom : Namespace ( time = 3 , walk = Namespace ( speed = 7 , distance = 42 )) This behaviour results in a final namespace structure which is much easier to parse, where subcommands are easily identified and nested into their own namespace recursively. Source code in pydantic_argparse/argparse/actions.py class SubParsersAction ( argparse . _SubParsersAction ): # pylint: disable=protected-access \"\"\"Recursively Nesting Sub-Parsers Action for Typed Argument Parsing This custom action differs in functionality from the existing standard argparse SubParsersAction because it nests the resultant sub-namespace directly into the supplied parent namespace, rather than iterating through and updating the parent namespace object with each argument individually. Example: Construct `ArgumentParser`: ```python # Create Argument Parser parser = argparse.ArgumentParser() # Add Example Global Argument parser.add_argument(\"--time\") # Add SubParsersAction subparsers = parser.add_subparsers() # Add Example 'walk' Command with Arguments walk = subparsers.add_parser(\"walk\") walk.add_argument(\"--speed\") walk.add_argument(\"--distance\") # Add Example 'talk' Command with Arguments talk = subparsers.add_parser(\"talk\") talk.add_argument(\"--volume\") talk.add_argument(\"--topic\") ``` Parse the Arguments: ```console --time 3 walk --speed 7 --distance 42 ``` Check Resultant Namespaces: ```python Original: Namespace(time=3, speed=7, distance=42) Custom: Namespace(time=3, walk=Namespace(speed=7, distance=42)) ``` This behaviour results in a final namespace structure which is much easier to parse, where subcommands are easily identified and nested into their own namespace recursively. \"\"\" def __call__ ( self , parser : argparse . ArgumentParser , namespace : argparse . Namespace , values : Union [ str , Sequence [ Any ], None ], option_string : Optional [ str ] = None , ) -> None : \"\"\"Parses arguments with the specified subparser, then embeds the resultant sub-namespace into the supplied parent namespace. Args: parser (argparse.ArgumentParser): Parent argument parser object. namespace (argparse.Namespace): Parent namespace being parsed to. values (Union[str, Sequence[Any], None]): Arguments to parse. option_string (Optional[str]): Optional option string (not used). Raises: argparse.ArgumentError: Raised if subparser name does not exist. \"\"\" # Check values object is a sequence # In order to not violate the Liskov Substitution Principle (LSP), the # function signature for __call__ must match the base Action class. As # such, this function signature also accepts 'str' and 'None' types for # the values argument. However, in reality, this should only ever be a # list of strings here, so we just do a type cast. values = cast ( list [ str ], values ) # Get Parser Name and Remaining Argument Strings parser_name , * arg_strings = values # Try select the parser try : # Select the parser parser = self . _name_parser_map [ parser_name ] except KeyError as exc : # Parser doesn't exist, raise an exception raise argparse . ArgumentError ( self , f \"unknown parser { parser_name } (choices: { ', ' . join ( self . _name_parser_map ) } )\" ) from exc # Parse all the remaining options into a sub-namespace, then embed this # sub-namespace into the parent namespace subnamespace , arg_strings = parser . parse_known_args ( arg_strings ) setattr ( namespace , parser_name , subnamespace ) # Store any unrecognized options on the parent namespace, so that the # top level parser can decide what to do with them if arg_strings : vars ( namespace ) . setdefault ( argparse . _UNRECOGNIZED_ARGS_ATTR , []) getattr ( namespace , argparse . _UNRECOGNIZED_ARGS_ATTR ) . extend ( arg_strings )","title":"SubParsersAction"},{"location":"reference/pydantic_argparse/argparse/actions/#pydantic_argparse.argparse.actions.SubParsersAction.__call__","text":"Parses arguments with the specified subparser, then embeds the resultant sub-namespace into the supplied parent namespace. Parameters: Name Type Description Default parser argparse.ArgumentParser Parent argument parser object. required namespace argparse.Namespace Parent namespace being parsed to. required values Union[str, Sequence[Any], None] Arguments to parse. required option_string Optional[str] Optional option string (not used). None Exceptions: Type Description argparse.ArgumentError Raised if subparser name does not exist. Source code in pydantic_argparse/argparse/actions.py def __call__ ( self , parser : argparse . ArgumentParser , namespace : argparse . Namespace , values : Union [ str , Sequence [ Any ], None ], option_string : Optional [ str ] = None , ) -> None : \"\"\"Parses arguments with the specified subparser, then embeds the resultant sub-namespace into the supplied parent namespace. Args: parser (argparse.ArgumentParser): Parent argument parser object. namespace (argparse.Namespace): Parent namespace being parsed to. values (Union[str, Sequence[Any], None]): Arguments to parse. option_string (Optional[str]): Optional option string (not used). Raises: argparse.ArgumentError: Raised if subparser name does not exist. \"\"\" # Check values object is a sequence # In order to not violate the Liskov Substitution Principle (LSP), the # function signature for __call__ must match the base Action class. As # such, this function signature also accepts 'str' and 'None' types for # the values argument. However, in reality, this should only ever be a # list of strings here, so we just do a type cast. values = cast ( list [ str ], values ) # Get Parser Name and Remaining Argument Strings parser_name , * arg_strings = values # Try select the parser try : # Select the parser parser = self . _name_parser_map [ parser_name ] except KeyError as exc : # Parser doesn't exist, raise an exception raise argparse . ArgumentError ( self , f \"unknown parser { parser_name } (choices: { ', ' . join ( self . _name_parser_map ) } )\" ) from exc # Parse all the remaining options into a sub-namespace, then embed this # sub-namespace into the parent namespace subnamespace , arg_strings = parser . parse_known_args ( arg_strings ) setattr ( namespace , parser_name , subnamespace ) # Store any unrecognized options on the parent namespace, so that the # top level parser can decide what to do with them if arg_strings : vars ( namespace ) . setdefault ( argparse . _UNRECOGNIZED_ARGS_ATTR , []) getattr ( namespace , argparse . _UNRECOGNIZED_ARGS_ATTR ) . extend ( arg_strings )","title":"__call__()"},{"location":"reference/pydantic_argparse/argparse/parser/","text":"parser Declarative and Typed Argument Parser. The parser module contains the ArgumentParser class, which provides a declarative method of defining command-line interfaces. The procedure to declaratively define a typed command-line interface is: Define pydantic arguments model Create typed ArgumentParser Parse typed arguments The resultant arguments object returned is an instance of the defined pydantic model. This means that the arguments object and its attributes will be compatible with an IDE, linter or type checker. ArgumentParser Declarative and Typed Argument Parser. The ArgumentParser declaratively generates a command-line interface using the pydantic model specified upon instantiation. The ArgumentParser provides the following argparse functionality: Required Arguments Optional Arguments Subcommands All arguments are named , and positional arguments are not supported. The ArgumentParser provides the method parse_typed_args() to parse command line arguments and return an instance of its bound pydantic model, populated with the parsed and validated user supplied command-line arguments. Source code in pydantic_argparse/argparse/parser.py class ArgumentParser ( argparse . ArgumentParser , Generic [ PydanticModelT ]): \"\"\"Declarative and Typed Argument Parser. The `ArgumentParser` declaratively generates a command-line interface using the `pydantic` model specified upon instantiation. The `ArgumentParser` provides the following `argparse` functionality: * Required Arguments * Optional Arguments * Subcommands All arguments are *named*, and positional arguments are not supported. The `ArgumentParser` provides the method `parse_typed_args()` to parse command line arguments and return an instance of its bound `pydantic` model, populated with the parsed and validated user supplied command-line arguments. \"\"\" # Argument Group Names COMMANDS = \"commands\" REQUIRED = \"required arguments\" OPTIONAL = \"optional arguments\" HELP = \"help\" # Keyword Arguments KWARG_REQUIRED = \"required\" # Exit Codes EXIT_ERROR = 2 def __init__ ( self , model : type [ PydanticModelT ], prog : Optional [ str ] = None , description : Optional [ str ] = None , version : Optional [ str ] = None , epilog : Optional [ str ] = None , add_help : bool = True , exit_on_error : bool = True , ) -> None : \"\"\"Instantiates the Typed Argument Parser with its `pydantic` model. Args: model (type[PydanticModelT]): Pydantic argument model class. prog (Optional[str]): Program name for CLI. description (Optional[str]): Program description for CLI. version (Optional[str]): Program version string for CLI. epilog (Optional[str]): Optional text following help message. add_help (bool): Whether to add a `-h`/`--help` flag. exit_on_error (bool): Whether to exit on error. \"\"\" # Initialise Super Class super () . __init__ ( prog = prog , description = description , epilog = epilog , exit_on_error = exit_on_error , add_help = False , # Always disable the automatic help flag. ) # Set Model self . model = model # Set Add Help and Exit on Error Flag self . add_help = add_help self . exit_on_error = exit_on_error # Set Version and Model self . version = version self . model = model # Add Arguments Groups self . _subcommands : Optional [ argparse . _SubParsersAction ] = None self . _required_group = self . add_argument_group ( ArgumentParser . REQUIRED ) self . _optional_group = self . add_argument_group ( ArgumentParser . OPTIONAL ) self . _help_group = self . add_argument_group ( ArgumentParser . HELP ) # Add Help and Version Flags if self . add_help : self . _add_help_flag () if self . version : self . _add_version_flag () # Add Arguments from Model self . _add_model ( model ) def parse_typed_args ( self , args : Optional [ list [ str ]] = None , ) -> PydanticModelT : \"\"\"Parses command line arguments. If `args` are not supplied by the user, then they are automatically retrieved from the `sys.argv` command-line arguments. Args: args (Optional[list[str]]): Optional list of arguments to parse. Returns: PydanticModelT: Populated instance of typed arguments model. Raises: argparse.ArgumentError: Raised upon error, if not exiting on error. SystemExit: Raised upon error, if exiting on error. \"\"\" # Call Super Class Method namespace = self . parse_args ( args ) # Convert Namespace to Dictionary arguments = utils . namespace_to_dict ( namespace ) # Handle Possible Validation Errors try : # Convert Namespace to Pydantic Model model = self . model . parse_obj ( arguments ) except pydantic . ValidationError as exc : # Catch exception, and use the ArgumentParser.error() method # to report it to the user self . error ( str ( exc )) # Return return model def add_argument ( self , * args : Any , ** kwargs : Any , ) -> argparse . Action : \"\"\"Adds an argument to the ArgumentParser. Args: *args (Any): Positional args to be passed to super class method. **kwargs (Any): Keyword args to be passed to super class method. Returns: argparse.Action: Action generated by the argument. \"\"\" # Check whether required or optional if kwargs . get ( ArgumentParser . KWARG_REQUIRED ): # Required group = self . _required_group else : # Optional group = self . _optional_group # Return Action return group . add_argument ( * args , ** kwargs ) def error ( self , message : str ) -> NoReturn : \"\"\"Prints a usage message to `stderr` and exits if required. Args: message (str): Message to print to the user. Raises: argparse.ArgumentError: Raised if not exiting on error. SystemExit: Raised if exiting on error. \"\"\" # Print usage message self . print_usage ( sys . stderr ) # Check whether parser should exit if self . exit_on_error : self . exit ( ArgumentParser . EXIT_ERROR , f \" { self . prog } : error: { message } \\n \" ) # Raise Error raise argparse . ArgumentError ( None , f \" { self . prog } : error: { message } \" ) def _add_help_flag ( self ) -> None : \"\"\"Adds help flag to argparser.\"\"\" # Add help flag self . _help_group . add_argument ( \"-h\" , \"--help\" , action = argparse . _HelpAction , # pylint: disable=protected-access help = \"show this help message and exit\" , ) def _add_version_flag ( self ) -> None : \"\"\"Adds version flag to argparser.\"\"\" # Add version flag self . _help_group . add_argument ( \"-v\" , \"--version\" , action = argparse . _VersionAction , # pylint: disable=protected-access help = \"show program's version number and exit\" , ) def _add_model ( self , model : type [ PydanticModelT ]) -> None : \"\"\"Adds pydantic model to argument parser. Args: model (type[PydanticModelT]): Pydantic model class to add to the argument parser. \"\"\" # Loop through fields in model for field in model . __fields__ . values (): # Add Field self . _add_field ( field ) def _add_field ( self , field : pydantic . fields . ModelField ) -> None : \"\"\"Adds pydantic field to argument parser. Args: field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Get Field Type and Possible Origin field_type = field . outer_type_ field_origin = typing_inspect . get_origin ( field_type ) # Switch on Field Type if field_type is bool : # Add Boolean Field parsers . parse_boolean_field ( self , field ) elif field_origin in ( list , tuple , set , frozenset , collections . deque ): # Add Container Field parsers . parse_container_field ( self , field ) elif field_origin is dict : # Add Dictionary (JSON) Field parsers . parse_json_field ( self , field ) elif field_origin is Literal : # Add Literal Field parsers . parse_literal_field ( self , field ) elif isinstance ( field_type , enum . EnumMeta ): # Add Enum Field parsers . parse_enum_field ( self , field ) elif isinstance ( field_type , pydantic . main . ModelMetaclass ): # Check for Sub-Commands Group if not self . _subcommands : # Add Sub-Commands Group self . _subcommands = self . add_subparsers ( title = ArgumentParser . COMMANDS , action = actions . SubParsersAction , required = True , ) # Shuffle it to the top self . _action_groups . insert ( 0 , self . _action_groups . pop ()) # Add Command parsers . parse_command_field ( self . _subcommands , field ) else : # Add Other Standard Field parsers . parse_standard_field ( self , field ) __init__ ( self , model , prog = None , description = None , version = None , epilog = None , add_help = True , exit_on_error = True ) special Instantiates the Typed Argument Parser with its pydantic model. Parameters: Name Type Description Default model type[PydanticModelT] Pydantic argument model class. required prog Optional[str] Program name for CLI. None description Optional[str] Program description for CLI. None version Optional[str] Program version string for CLI. None epilog Optional[str] Optional text following help message. None add_help bool Whether to add a -h / --help flag. True exit_on_error bool Whether to exit on error. True Source code in pydantic_argparse/argparse/parser.py def __init__ ( self , model : type [ PydanticModelT ], prog : Optional [ str ] = None , description : Optional [ str ] = None , version : Optional [ str ] = None , epilog : Optional [ str ] = None , add_help : bool = True , exit_on_error : bool = True , ) -> None : \"\"\"Instantiates the Typed Argument Parser with its `pydantic` model. Args: model (type[PydanticModelT]): Pydantic argument model class. prog (Optional[str]): Program name for CLI. description (Optional[str]): Program description for CLI. version (Optional[str]): Program version string for CLI. epilog (Optional[str]): Optional text following help message. add_help (bool): Whether to add a `-h`/`--help` flag. exit_on_error (bool): Whether to exit on error. \"\"\" # Initialise Super Class super () . __init__ ( prog = prog , description = description , epilog = epilog , exit_on_error = exit_on_error , add_help = False , # Always disable the automatic help flag. ) # Set Model self . model = model # Set Add Help and Exit on Error Flag self . add_help = add_help self . exit_on_error = exit_on_error # Set Version and Model self . version = version self . model = model # Add Arguments Groups self . _subcommands : Optional [ argparse . _SubParsersAction ] = None self . _required_group = self . add_argument_group ( ArgumentParser . REQUIRED ) self . _optional_group = self . add_argument_group ( ArgumentParser . OPTIONAL ) self . _help_group = self . add_argument_group ( ArgumentParser . HELP ) # Add Help and Version Flags if self . add_help : self . _add_help_flag () if self . version : self . _add_version_flag () # Add Arguments from Model self . _add_model ( model ) parse_typed_args ( self , args = None ) Parses command line arguments. If args are not supplied by the user, then they are automatically retrieved from the sys.argv command-line arguments. Parameters: Name Type Description Default args Optional[list[str]] Optional list of arguments to parse. None Returns: Type Description PydanticModelT Populated instance of typed arguments model. Exceptions: Type Description argparse.ArgumentError Raised upon error, if not exiting on error. SystemExit Raised upon error, if exiting on error. Source code in pydantic_argparse/argparse/parser.py def parse_typed_args ( self , args : Optional [ list [ str ]] = None , ) -> PydanticModelT : \"\"\"Parses command line arguments. If `args` are not supplied by the user, then they are automatically retrieved from the `sys.argv` command-line arguments. Args: args (Optional[list[str]]): Optional list of arguments to parse. Returns: PydanticModelT: Populated instance of typed arguments model. Raises: argparse.ArgumentError: Raised upon error, if not exiting on error. SystemExit: Raised upon error, if exiting on error. \"\"\" # Call Super Class Method namespace = self . parse_args ( args ) # Convert Namespace to Dictionary arguments = utils . namespace_to_dict ( namespace ) # Handle Possible Validation Errors try : # Convert Namespace to Pydantic Model model = self . model . parse_obj ( arguments ) except pydantic . ValidationError as exc : # Catch exception, and use the ArgumentParser.error() method # to report it to the user self . error ( str ( exc )) # Return return model add_argument ( self , * args , ** kwargs ) Adds an argument to the ArgumentParser. Parameters: Name Type Description Default *args Any Positional args to be passed to super class method. () **kwargs Any Keyword args to be passed to super class method. {} Returns: Type Description argparse.Action Action generated by the argument. Source code in pydantic_argparse/argparse/parser.py def add_argument ( self , * args : Any , ** kwargs : Any , ) -> argparse . Action : \"\"\"Adds an argument to the ArgumentParser. Args: *args (Any): Positional args to be passed to super class method. **kwargs (Any): Keyword args to be passed to super class method. Returns: argparse.Action: Action generated by the argument. \"\"\" # Check whether required or optional if kwargs . get ( ArgumentParser . KWARG_REQUIRED ): # Required group = self . _required_group else : # Optional group = self . _optional_group # Return Action return group . add_argument ( * args , ** kwargs ) error ( self , message ) Prints a usage message to stderr and exits if required. Parameters: Name Type Description Default message str Message to print to the user. required Exceptions: Type Description argparse.ArgumentError Raised if not exiting on error. SystemExit Raised if exiting on error. Source code in pydantic_argparse/argparse/parser.py def error ( self , message : str ) -> NoReturn : \"\"\"Prints a usage message to `stderr` and exits if required. Args: message (str): Message to print to the user. Raises: argparse.ArgumentError: Raised if not exiting on error. SystemExit: Raised if exiting on error. \"\"\" # Print usage message self . print_usage ( sys . stderr ) # Check whether parser should exit if self . exit_on_error : self . exit ( ArgumentParser . EXIT_ERROR , f \" { self . prog } : error: { message } \\n \" ) # Raise Error raise argparse . ArgumentError ( None , f \" { self . prog } : error: { message } \" )","title":"parser.py"},{"location":"reference/pydantic_argparse/argparse/parser/#parser","text":"Declarative and Typed Argument Parser. The parser module contains the ArgumentParser class, which provides a declarative method of defining command-line interfaces. The procedure to declaratively define a typed command-line interface is: Define pydantic arguments model Create typed ArgumentParser Parse typed arguments The resultant arguments object returned is an instance of the defined pydantic model. This means that the arguments object and its attributes will be compatible with an IDE, linter or type checker.","title":"parser"},{"location":"reference/pydantic_argparse/argparse/parser/#pydantic_argparse.argparse.parser.ArgumentParser","text":"Declarative and Typed Argument Parser. The ArgumentParser declaratively generates a command-line interface using the pydantic model specified upon instantiation. The ArgumentParser provides the following argparse functionality: Required Arguments Optional Arguments Subcommands All arguments are named , and positional arguments are not supported. The ArgumentParser provides the method parse_typed_args() to parse command line arguments and return an instance of its bound pydantic model, populated with the parsed and validated user supplied command-line arguments. Source code in pydantic_argparse/argparse/parser.py class ArgumentParser ( argparse . ArgumentParser , Generic [ PydanticModelT ]): \"\"\"Declarative and Typed Argument Parser. The `ArgumentParser` declaratively generates a command-line interface using the `pydantic` model specified upon instantiation. The `ArgumentParser` provides the following `argparse` functionality: * Required Arguments * Optional Arguments * Subcommands All arguments are *named*, and positional arguments are not supported. The `ArgumentParser` provides the method `parse_typed_args()` to parse command line arguments and return an instance of its bound `pydantic` model, populated with the parsed and validated user supplied command-line arguments. \"\"\" # Argument Group Names COMMANDS = \"commands\" REQUIRED = \"required arguments\" OPTIONAL = \"optional arguments\" HELP = \"help\" # Keyword Arguments KWARG_REQUIRED = \"required\" # Exit Codes EXIT_ERROR = 2 def __init__ ( self , model : type [ PydanticModelT ], prog : Optional [ str ] = None , description : Optional [ str ] = None , version : Optional [ str ] = None , epilog : Optional [ str ] = None , add_help : bool = True , exit_on_error : bool = True , ) -> None : \"\"\"Instantiates the Typed Argument Parser with its `pydantic` model. Args: model (type[PydanticModelT]): Pydantic argument model class. prog (Optional[str]): Program name for CLI. description (Optional[str]): Program description for CLI. version (Optional[str]): Program version string for CLI. epilog (Optional[str]): Optional text following help message. add_help (bool): Whether to add a `-h`/`--help` flag. exit_on_error (bool): Whether to exit on error. \"\"\" # Initialise Super Class super () . __init__ ( prog = prog , description = description , epilog = epilog , exit_on_error = exit_on_error , add_help = False , # Always disable the automatic help flag. ) # Set Model self . model = model # Set Add Help and Exit on Error Flag self . add_help = add_help self . exit_on_error = exit_on_error # Set Version and Model self . version = version self . model = model # Add Arguments Groups self . _subcommands : Optional [ argparse . _SubParsersAction ] = None self . _required_group = self . add_argument_group ( ArgumentParser . REQUIRED ) self . _optional_group = self . add_argument_group ( ArgumentParser . OPTIONAL ) self . _help_group = self . add_argument_group ( ArgumentParser . HELP ) # Add Help and Version Flags if self . add_help : self . _add_help_flag () if self . version : self . _add_version_flag () # Add Arguments from Model self . _add_model ( model ) def parse_typed_args ( self , args : Optional [ list [ str ]] = None , ) -> PydanticModelT : \"\"\"Parses command line arguments. If `args` are not supplied by the user, then they are automatically retrieved from the `sys.argv` command-line arguments. Args: args (Optional[list[str]]): Optional list of arguments to parse. Returns: PydanticModelT: Populated instance of typed arguments model. Raises: argparse.ArgumentError: Raised upon error, if not exiting on error. SystemExit: Raised upon error, if exiting on error. \"\"\" # Call Super Class Method namespace = self . parse_args ( args ) # Convert Namespace to Dictionary arguments = utils . namespace_to_dict ( namespace ) # Handle Possible Validation Errors try : # Convert Namespace to Pydantic Model model = self . model . parse_obj ( arguments ) except pydantic . ValidationError as exc : # Catch exception, and use the ArgumentParser.error() method # to report it to the user self . error ( str ( exc )) # Return return model def add_argument ( self , * args : Any , ** kwargs : Any , ) -> argparse . Action : \"\"\"Adds an argument to the ArgumentParser. Args: *args (Any): Positional args to be passed to super class method. **kwargs (Any): Keyword args to be passed to super class method. Returns: argparse.Action: Action generated by the argument. \"\"\" # Check whether required or optional if kwargs . get ( ArgumentParser . KWARG_REQUIRED ): # Required group = self . _required_group else : # Optional group = self . _optional_group # Return Action return group . add_argument ( * args , ** kwargs ) def error ( self , message : str ) -> NoReturn : \"\"\"Prints a usage message to `stderr` and exits if required. Args: message (str): Message to print to the user. Raises: argparse.ArgumentError: Raised if not exiting on error. SystemExit: Raised if exiting on error. \"\"\" # Print usage message self . print_usage ( sys . stderr ) # Check whether parser should exit if self . exit_on_error : self . exit ( ArgumentParser . EXIT_ERROR , f \" { self . prog } : error: { message } \\n \" ) # Raise Error raise argparse . ArgumentError ( None , f \" { self . prog } : error: { message } \" ) def _add_help_flag ( self ) -> None : \"\"\"Adds help flag to argparser.\"\"\" # Add help flag self . _help_group . add_argument ( \"-h\" , \"--help\" , action = argparse . _HelpAction , # pylint: disable=protected-access help = \"show this help message and exit\" , ) def _add_version_flag ( self ) -> None : \"\"\"Adds version flag to argparser.\"\"\" # Add version flag self . _help_group . add_argument ( \"-v\" , \"--version\" , action = argparse . _VersionAction , # pylint: disable=protected-access help = \"show program's version number and exit\" , ) def _add_model ( self , model : type [ PydanticModelT ]) -> None : \"\"\"Adds pydantic model to argument parser. Args: model (type[PydanticModelT]): Pydantic model class to add to the argument parser. \"\"\" # Loop through fields in model for field in model . __fields__ . values (): # Add Field self . _add_field ( field ) def _add_field ( self , field : pydantic . fields . ModelField ) -> None : \"\"\"Adds pydantic field to argument parser. Args: field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Get Field Type and Possible Origin field_type = field . outer_type_ field_origin = typing_inspect . get_origin ( field_type ) # Switch on Field Type if field_type is bool : # Add Boolean Field parsers . parse_boolean_field ( self , field ) elif field_origin in ( list , tuple , set , frozenset , collections . deque ): # Add Container Field parsers . parse_container_field ( self , field ) elif field_origin is dict : # Add Dictionary (JSON) Field parsers . parse_json_field ( self , field ) elif field_origin is Literal : # Add Literal Field parsers . parse_literal_field ( self , field ) elif isinstance ( field_type , enum . EnumMeta ): # Add Enum Field parsers . parse_enum_field ( self , field ) elif isinstance ( field_type , pydantic . main . ModelMetaclass ): # Check for Sub-Commands Group if not self . _subcommands : # Add Sub-Commands Group self . _subcommands = self . add_subparsers ( title = ArgumentParser . COMMANDS , action = actions . SubParsersAction , required = True , ) # Shuffle it to the top self . _action_groups . insert ( 0 , self . _action_groups . pop ()) # Add Command parsers . parse_command_field ( self . _subcommands , field ) else : # Add Other Standard Field parsers . parse_standard_field ( self , field )","title":"ArgumentParser"},{"location":"reference/pydantic_argparse/argparse/parser/#pydantic_argparse.argparse.parser.ArgumentParser.__init__","text":"Instantiates the Typed Argument Parser with its pydantic model. Parameters: Name Type Description Default model type[PydanticModelT] Pydantic argument model class. required prog Optional[str] Program name for CLI. None description Optional[str] Program description for CLI. None version Optional[str] Program version string for CLI. None epilog Optional[str] Optional text following help message. None add_help bool Whether to add a -h / --help flag. True exit_on_error bool Whether to exit on error. True Source code in pydantic_argparse/argparse/parser.py def __init__ ( self , model : type [ PydanticModelT ], prog : Optional [ str ] = None , description : Optional [ str ] = None , version : Optional [ str ] = None , epilog : Optional [ str ] = None , add_help : bool = True , exit_on_error : bool = True , ) -> None : \"\"\"Instantiates the Typed Argument Parser with its `pydantic` model. Args: model (type[PydanticModelT]): Pydantic argument model class. prog (Optional[str]): Program name for CLI. description (Optional[str]): Program description for CLI. version (Optional[str]): Program version string for CLI. epilog (Optional[str]): Optional text following help message. add_help (bool): Whether to add a `-h`/`--help` flag. exit_on_error (bool): Whether to exit on error. \"\"\" # Initialise Super Class super () . __init__ ( prog = prog , description = description , epilog = epilog , exit_on_error = exit_on_error , add_help = False , # Always disable the automatic help flag. ) # Set Model self . model = model # Set Add Help and Exit on Error Flag self . add_help = add_help self . exit_on_error = exit_on_error # Set Version and Model self . version = version self . model = model # Add Arguments Groups self . _subcommands : Optional [ argparse . _SubParsersAction ] = None self . _required_group = self . add_argument_group ( ArgumentParser . REQUIRED ) self . _optional_group = self . add_argument_group ( ArgumentParser . OPTIONAL ) self . _help_group = self . add_argument_group ( ArgumentParser . HELP ) # Add Help and Version Flags if self . add_help : self . _add_help_flag () if self . version : self . _add_version_flag () # Add Arguments from Model self . _add_model ( model )","title":"__init__()"},{"location":"reference/pydantic_argparse/argparse/parser/#pydantic_argparse.argparse.parser.ArgumentParser.parse_typed_args","text":"Parses command line arguments. If args are not supplied by the user, then they are automatically retrieved from the sys.argv command-line arguments. Parameters: Name Type Description Default args Optional[list[str]] Optional list of arguments to parse. None Returns: Type Description PydanticModelT Populated instance of typed arguments model. Exceptions: Type Description argparse.ArgumentError Raised upon error, if not exiting on error. SystemExit Raised upon error, if exiting on error. Source code in pydantic_argparse/argparse/parser.py def parse_typed_args ( self , args : Optional [ list [ str ]] = None , ) -> PydanticModelT : \"\"\"Parses command line arguments. If `args` are not supplied by the user, then they are automatically retrieved from the `sys.argv` command-line arguments. Args: args (Optional[list[str]]): Optional list of arguments to parse. Returns: PydanticModelT: Populated instance of typed arguments model. Raises: argparse.ArgumentError: Raised upon error, if not exiting on error. SystemExit: Raised upon error, if exiting on error. \"\"\" # Call Super Class Method namespace = self . parse_args ( args ) # Convert Namespace to Dictionary arguments = utils . namespace_to_dict ( namespace ) # Handle Possible Validation Errors try : # Convert Namespace to Pydantic Model model = self . model . parse_obj ( arguments ) except pydantic . ValidationError as exc : # Catch exception, and use the ArgumentParser.error() method # to report it to the user self . error ( str ( exc )) # Return return model","title":"parse_typed_args()"},{"location":"reference/pydantic_argparse/argparse/parser/#pydantic_argparse.argparse.parser.ArgumentParser.add_argument","text":"Adds an argument to the ArgumentParser. Parameters: Name Type Description Default *args Any Positional args to be passed to super class method. () **kwargs Any Keyword args to be passed to super class method. {} Returns: Type Description argparse.Action Action generated by the argument. Source code in pydantic_argparse/argparse/parser.py def add_argument ( self , * args : Any , ** kwargs : Any , ) -> argparse . Action : \"\"\"Adds an argument to the ArgumentParser. Args: *args (Any): Positional args to be passed to super class method. **kwargs (Any): Keyword args to be passed to super class method. Returns: argparse.Action: Action generated by the argument. \"\"\" # Check whether required or optional if kwargs . get ( ArgumentParser . KWARG_REQUIRED ): # Required group = self . _required_group else : # Optional group = self . _optional_group # Return Action return group . add_argument ( * args , ** kwargs )","title":"add_argument()"},{"location":"reference/pydantic_argparse/argparse/parser/#pydantic_argparse.argparse.parser.ArgumentParser.error","text":"Prints a usage message to stderr and exits if required. Parameters: Name Type Description Default message str Message to print to the user. required Exceptions: Type Description argparse.ArgumentError Raised if not exiting on error. SystemExit Raised if exiting on error. Source code in pydantic_argparse/argparse/parser.py def error ( self , message : str ) -> NoReturn : \"\"\"Prints a usage message to `stderr` and exits if required. Args: message (str): Message to print to the user. Raises: argparse.ArgumentError: Raised if not exiting on error. SystemExit: Raised if exiting on error. \"\"\" # Print usage message self . print_usage ( sys . stderr ) # Check whether parser should exit if self . exit_on_error : self . exit ( ArgumentParser . EXIT_ERROR , f \" { self . prog } : error: { message } \\n \" ) # Raise Error raise argparse . ArgumentError ( None , f \" { self . prog } : error: { message } \" )","title":"error()"},{"location":"reference/pydantic_argparse/parsers/","text":"parsers __init__.py Parses Pydantic Fields to Command-Line Arguments. This package contains the methods required for parsing pydantic model fields to ArgumentParser command-line arguments. The public interface exposed by this package is the parsing functions, which take an argparse.ArgumentParser and a pydantic.fields.ModelField , parse the field and add a new argument to the ArgumentParser .","title":"parsers"},{"location":"reference/pydantic_argparse/parsers/#parsers","text":"","title":"parsers"},{"location":"reference/pydantic_argparse/parsers/#__init__py","text":"Parses Pydantic Fields to Command-Line Arguments. This package contains the methods required for parsing pydantic model fields to ArgumentParser command-line arguments. The public interface exposed by this package is the parsing functions, which take an argparse.ArgumentParser and a pydantic.fields.ModelField , parse the field and add a new argument to the ArgumentParser .","title":"__init__.py"},{"location":"reference/pydantic_argparse/parsers/boolean/","text":"boolean Parses Boolean Pydantic Fields to Command-Line Arguments. The boolean module contains the parse_boolean_field method, which parses boolean pydantic model fields to ArgumentParser command-line arguments. parse_boolean_field ( parser , field ) Adds boolean pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/boolean.py def parse_boolean_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds boolean pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Booleans can be treated as required or optional flags if field . required : # Required _parse_boolean_field_required ( parser , field ) else : # Optional _parse_boolean_field_optional ( parser , field )","title":"boolean.py"},{"location":"reference/pydantic_argparse/parsers/boolean/#boolean","text":"Parses Boolean Pydantic Fields to Command-Line Arguments. The boolean module contains the parse_boolean_field method, which parses boolean pydantic model fields to ArgumentParser command-line arguments.","title":"boolean"},{"location":"reference/pydantic_argparse/parsers/boolean/#pydantic_argparse.parsers.boolean.parse_boolean_field","text":"Adds boolean pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/boolean.py def parse_boolean_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds boolean pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Booleans can be treated as required or optional flags if field . required : # Required _parse_boolean_field_required ( parser , field ) else : # Optional _parse_boolean_field_optional ( parser , field )","title":"parse_boolean_field()"},{"location":"reference/pydantic_argparse/parsers/command/","text":"command Parses Nested Pydantic Model Fields to Sub-Commands. The command module contains the parse_command_field method, which parses nested pydantic model fields to ArgumentParser sub-commands. parse_command_field ( subparser , field ) Adds command pydantic field to argument parser. Parameters: Name Type Description Default subparser argparse._SubParsersAction Sub-parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/command.py def parse_command_field ( subparser : argparse . _SubParsersAction , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds command pydantic field to argument parser. Args: subparser (argparse._SubParsersAction): Sub-parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Add Command subparser . add_parser ( field . name , help = field . field_info . description , model = field . outer_type_ , exit_on_error = False , # Allow top level parser to handle exiting )","title":"command.py"},{"location":"reference/pydantic_argparse/parsers/command/#command","text":"Parses Nested Pydantic Model Fields to Sub-Commands. The command module contains the parse_command_field method, which parses nested pydantic model fields to ArgumentParser sub-commands.","title":"command"},{"location":"reference/pydantic_argparse/parsers/command/#pydantic_argparse.parsers.command.parse_command_field","text":"Adds command pydantic field to argument parser. Parameters: Name Type Description Default subparser argparse._SubParsersAction Sub-parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/command.py def parse_command_field ( subparser : argparse . _SubParsersAction , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds command pydantic field to argument parser. Args: subparser (argparse._SubParsersAction): Sub-parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Add Command subparser . add_parser ( field . name , help = field . field_info . description , model = field . outer_type_ , exit_on_error = False , # Allow top level parser to handle exiting )","title":"parse_command_field()"},{"location":"reference/pydantic_argparse/parsers/container/","text":"container Parses Container Pydantic Fields to Command-Line Arguments. The container module contains the parse_container_field method, which parses container pydantic model fields to ArgumentParser command-line arguments. parse_container_field ( parser , field ) Adds standard pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/container.py def parse_container_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds standard pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # List, Tuple, Set, FrozenSet, Deque if field . required : # Required _parse_container_field_required ( parser , field ) else : # Optional _parse_container_field_optional ( parser , field )","title":"container.py"},{"location":"reference/pydantic_argparse/parsers/container/#container","text":"Parses Container Pydantic Fields to Command-Line Arguments. The container module contains the parse_container_field method, which parses container pydantic model fields to ArgumentParser command-line arguments.","title":"container"},{"location":"reference/pydantic_argparse/parsers/container/#pydantic_argparse.parsers.container.parse_container_field","text":"Adds standard pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/container.py def parse_container_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds standard pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # List, Tuple, Set, FrozenSet, Deque if field . required : # Required _parse_container_field_required ( parser , field ) else : # Optional _parse_container_field_optional ( parser , field )","title":"parse_container_field()"},{"location":"reference/pydantic_argparse/parsers/enum/","text":"enum Parses Enum Pydantic Fields to Command-Line Arguments. The enum module contains the parse_enum_field method, which parses enum pydantic model fields to ArgumentParser command-line arguments. parse_enum_field ( parser , field ) Adds enum pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/enum.py def parse_enum_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds enum pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Enums are treated as choices if field . required : # Required _parse_enum_field_required ( parser , field ) else : # Optional _parse_enum_field_optional ( parser , field )","title":"enum.py"},{"location":"reference/pydantic_argparse/parsers/enum/#enum","text":"Parses Enum Pydantic Fields to Command-Line Arguments. The enum module contains the parse_enum_field method, which parses enum pydantic model fields to ArgumentParser command-line arguments.","title":"enum"},{"location":"reference/pydantic_argparse/parsers/enum/#pydantic_argparse.parsers.enum.parse_enum_field","text":"Adds enum pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/enum.py def parse_enum_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds enum pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Enums are treated as choices if field . required : # Required _parse_enum_field_required ( parser , field ) else : # Optional _parse_enum_field_optional ( parser , field )","title":"parse_enum_field()"},{"location":"reference/pydantic_argparse/parsers/json/","text":"json Parses JSON Pydantic Fields to Command-Line Arguments. The json module contains the parse_json_field method, which parses JSON pydantic model fields to ArgumentParser command-line arguments. parse_json_field ( parser , field ) Adds json pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/json.py def parse_json_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds json pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # JSON (Dictionary) if field . required : # Required _parse_json_field_required ( parser , field ) else : # Optional _parse_json_field_optional ( parser , field )","title":"json.py"},{"location":"reference/pydantic_argparse/parsers/json/#json","text":"Parses JSON Pydantic Fields to Command-Line Arguments. The json module contains the parse_json_field method, which parses JSON pydantic model fields to ArgumentParser command-line arguments.","title":"json"},{"location":"reference/pydantic_argparse/parsers/json/#pydantic_argparse.parsers.json.parse_json_field","text":"Adds json pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/json.py def parse_json_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds json pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # JSON (Dictionary) if field . required : # Required _parse_json_field_required ( parser , field ) else : # Optional _parse_json_field_optional ( parser , field )","title":"parse_json_field()"},{"location":"reference/pydantic_argparse/parsers/literal/","text":"literal Parses Literal Pydantic Fields to Command-Line Arguments. The literal module contains the parse_literal_field method, which parses literal pydantic model fields to ArgumentParser command-line arguments. parse_literal_field ( parser , field ) Adds enum pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/literal.py def parse_literal_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds enum pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Literals are treated as constant flags, or choices if field . required : # Required _parse_literal_field_required ( parser , field ) else : # Optional _parse_literal_field_optional ( parser , field )","title":"literal.py"},{"location":"reference/pydantic_argparse/parsers/literal/#literal","text":"Parses Literal Pydantic Fields to Command-Line Arguments. The literal module contains the parse_literal_field method, which parses literal pydantic model fields to ArgumentParser command-line arguments.","title":"literal"},{"location":"reference/pydantic_argparse/parsers/literal/#pydantic_argparse.parsers.literal.parse_literal_field","text":"Adds enum pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/literal.py def parse_literal_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds enum pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Literals are treated as constant flags, or choices if field . required : # Required _parse_literal_field_required ( parser , field ) else : # Optional _parse_literal_field_optional ( parser , field )","title":"parse_literal_field()"},{"location":"reference/pydantic_argparse/parsers/standard/","text":"standard Parses Standard Pydantic Fields to Command-Line Arguments. The standard module contains the parse_standard_field method, which parses standard pydantic model fields to ArgumentParser command-line arguments. parse_standard_field ( parser , field ) Adds standard pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/standard.py def parse_standard_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds standard pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # All other types are treated in a standard way if field . required : # Required _parse_standard_field_required ( parser , field ) else : # Optional _parse_standard_field_optional ( parser , field )","title":"standard.py"},{"location":"reference/pydantic_argparse/parsers/standard/#standard","text":"Parses Standard Pydantic Fields to Command-Line Arguments. The standard module contains the parse_standard_field method, which parses standard pydantic model fields to ArgumentParser command-line arguments.","title":"standard"},{"location":"reference/pydantic_argparse/parsers/standard/#pydantic_argparse.parsers.standard.parse_standard_field","text":"Adds standard pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/standard.py def parse_standard_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds standard pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # All other types are treated in a standard way if field . required : # Required _parse_standard_field_required ( parser , field ) else : # Optional _parse_standard_field_optional ( parser , field )","title":"parse_standard_field()"},{"location":"reference/pydantic_argparse/utils/","text":"utils __init__.py Utility Functions for Declarative Typed Argument Parsing. This package contains helper functions for the typed argument parsing process, including formatting argument names and descriptions, recursively parsing argparse.Namespace objects to dict s and constructing named partial type casting functions. The public interface exposed by this package is various utility helper methods.","title":"utils"},{"location":"reference/pydantic_argparse/utils/#utils","text":"","title":"utils"},{"location":"reference/pydantic_argparse/utils/#__init__py","text":"Utility Functions for Declarative Typed Argument Parsing. This package contains helper functions for the typed argument parsing process, including formatting argument names and descriptions, recursively parsing argparse.Namespace objects to dict s and constructing named partial type casting functions. The public interface exposed by this package is various utility helper methods.","title":"__init__.py"},{"location":"reference/pydantic_argparse/utils/utils/","text":"utils Utility Functions for Declarative Typed Argument Parsing. The utils module contains various utility functions, including: argument_name : Formatting argument names. argument_description : Formatting argument descriptions. namespace_to_dict : Recursively parsing argparse.Namespace s to dict s. type_caster : Constructing named functools.partial type casting functions. The functionality outlined above is so common throughout the typed argument parsing process that the functions have been refactored out into this module as utility functions. argument_name ( name ) Standardises argument name. Examples: argument_name ( \"hello\" ) == \"--hello\" argument_name ( \"hello_world\" ) == \"--hello-world\" Parameters: Name Type Description Default name str Name of the argument. required Returns: Type Description str Standardised name of the argument. Source code in pydantic_argparse/utils/utils.py def argument_name ( name : str ) -> str : \"\"\"Standardises argument name. Examples: ```python argument_name(\"hello\") == \"--hello\" argument_name(\"hello_world\") == \"--hello-world\" ``` Args: name (str): Name of the argument. Returns: str: Standardised name of the argument. \"\"\" # Add '--', replace '_' with '-' return f \"-- { name . replace ( '_' , '-' ) } \" argument_description ( description , default =~ MISSING ) Standardises argument description. Examples: argument_description ( \"hello\" ) == \"hello\" argument_description ( \"hello\" , None ) == \"hello (default: None)\" argument_description ( \"hello\" , 42 ) == \"hello (default: 42)\" Parameters: Name Type Description Default description Optional[str] Optional description for argument. required default Optional[Any] Default value for argument if applicable. ~MISSING Returns: Type Description str Standardised description of the argument. Source code in pydantic_argparse/utils/utils.py def argument_description ( description : Optional [ str ], default : Optional [ Any ] = MISSING , ) -> str : \"\"\"Standardises argument description. Examples: ```python argument_description(\"hello\") == \"hello\" argument_description(\"hello\", None) == \"hello (default: None)\" argument_description(\"hello\", 42) == \"hello (default: 42)\" ``` Args: description (Optional[str]): Optional description for argument. default (Optional[Any]): Default value for argument if applicable. Returns: str: Standardised description of the argument. \"\"\" # Construct Default String default = f \"(default: { default } )\" if default is not MISSING else None # Return Standardised Description String return \" \" . join ( filter ( None , [ description , default ])) namespace_to_dict ( namespace ) Converts a nested namespace to a dictionary recursively. Parameters: Name Type Description Default namespace argparse.Namespace Namespace object to convert. required Returns: Type Description dict[str, Any] Nested dictionary generated from namespace. Source code in pydantic_argparse/utils/utils.py def namespace_to_dict ( namespace : argparse . Namespace ) -> dict [ str , Any ]: \"\"\"Converts a nested namespace to a dictionary recursively. Args: namespace (argparse.Namespace): Namespace object to convert. Returns: dict[str, Any]: Nested dictionary generated from namespace. \"\"\" # Get Dictionary from Namespace Vars dictionary = vars ( namespace ) # Loop Through Dictionary for ( key , value ) in dictionary . items (): # Check for Namespace Objects if isinstance ( value , argparse . Namespace ): # Recurse dictionary [ key ] = namespace_to_dict ( value ) # Return return dictionary type_caster ( name , function , ** kwargs ) Wraps a function to provide a type caster. Parameters: Name Type Description Default name str Name of the type caster (for nicer error messages) required function Callable[..., T] Callable function for type caster. required **kwargs Any Keyword arguments to pass to function. {} Returns: Type Description Callable[[str], T] Type caster named partial function. Source code in pydantic_argparse/utils/utils.py def type_caster ( name : str , function : Callable [ ... , T ], ** kwargs : Any , ) -> Callable [[ str ], T ]: \"\"\"Wraps a function to provide a type caster. Args: name (str): Name of the type caster (for nicer error messages) function (Callable[..., T]): Callable function for type caster. **kwargs (Any): Keyword arguments to pass to function. Returns: Callable[[str], T]: Type caster named partial function. \"\"\" # Create Partial Function and Set Name function = functools . partial ( function , ** kwargs ) setattr ( function , \"__name__\" , name ) # Return return function","title":"utils.py"},{"location":"reference/pydantic_argparse/utils/utils/#utils","text":"Utility Functions for Declarative Typed Argument Parsing. The utils module contains various utility functions, including: argument_name : Formatting argument names. argument_description : Formatting argument descriptions. namespace_to_dict : Recursively parsing argparse.Namespace s to dict s. type_caster : Constructing named functools.partial type casting functions. The functionality outlined above is so common throughout the typed argument parsing process that the functions have been refactored out into this module as utility functions.","title":"utils"},{"location":"reference/pydantic_argparse/utils/utils/#pydantic_argparse.utils.utils.argument_name","text":"Standardises argument name. Examples: argument_name ( \"hello\" ) == \"--hello\" argument_name ( \"hello_world\" ) == \"--hello-world\" Parameters: Name Type Description Default name str Name of the argument. required Returns: Type Description str Standardised name of the argument. Source code in pydantic_argparse/utils/utils.py def argument_name ( name : str ) -> str : \"\"\"Standardises argument name. Examples: ```python argument_name(\"hello\") == \"--hello\" argument_name(\"hello_world\") == \"--hello-world\" ``` Args: name (str): Name of the argument. Returns: str: Standardised name of the argument. \"\"\" # Add '--', replace '_' with '-' return f \"-- { name . replace ( '_' , '-' ) } \"","title":"argument_name()"},{"location":"reference/pydantic_argparse/utils/utils/#pydantic_argparse.utils.utils.argument_description","text":"Standardises argument description. Examples: argument_description ( \"hello\" ) == \"hello\" argument_description ( \"hello\" , None ) == \"hello (default: None)\" argument_description ( \"hello\" , 42 ) == \"hello (default: 42)\" Parameters: Name Type Description Default description Optional[str] Optional description for argument. required default Optional[Any] Default value for argument if applicable. ~MISSING Returns: Type Description str Standardised description of the argument. Source code in pydantic_argparse/utils/utils.py def argument_description ( description : Optional [ str ], default : Optional [ Any ] = MISSING , ) -> str : \"\"\"Standardises argument description. Examples: ```python argument_description(\"hello\") == \"hello\" argument_description(\"hello\", None) == \"hello (default: None)\" argument_description(\"hello\", 42) == \"hello (default: 42)\" ``` Args: description (Optional[str]): Optional description for argument. default (Optional[Any]): Default value for argument if applicable. Returns: str: Standardised description of the argument. \"\"\" # Construct Default String default = f \"(default: { default } )\" if default is not MISSING else None # Return Standardised Description String return \" \" . join ( filter ( None , [ description , default ]))","title":"argument_description()"},{"location":"reference/pydantic_argparse/utils/utils/#pydantic_argparse.utils.utils.namespace_to_dict","text":"Converts a nested namespace to a dictionary recursively. Parameters: Name Type Description Default namespace argparse.Namespace Namespace object to convert. required Returns: Type Description dict[str, Any] Nested dictionary generated from namespace. Source code in pydantic_argparse/utils/utils.py def namespace_to_dict ( namespace : argparse . Namespace ) -> dict [ str , Any ]: \"\"\"Converts a nested namespace to a dictionary recursively. Args: namespace (argparse.Namespace): Namespace object to convert. Returns: dict[str, Any]: Nested dictionary generated from namespace. \"\"\" # Get Dictionary from Namespace Vars dictionary = vars ( namespace ) # Loop Through Dictionary for ( key , value ) in dictionary . items (): # Check for Namespace Objects if isinstance ( value , argparse . Namespace ): # Recurse dictionary [ key ] = namespace_to_dict ( value ) # Return return dictionary","title":"namespace_to_dict()"},{"location":"reference/pydantic_argparse/utils/utils/#pydantic_argparse.utils.utils.type_caster","text":"Wraps a function to provide a type caster. Parameters: Name Type Description Default name str Name of the type caster (for nicer error messages) required function Callable[..., T] Callable function for type caster. required **kwargs Any Keyword arguments to pass to function. {} Returns: Type Description Callable[[str], T] Type caster named partial function. Source code in pydantic_argparse/utils/utils.py def type_caster ( name : str , function : Callable [ ... , T ], ** kwargs : Any , ) -> Callable [[ str ], T ]: \"\"\"Wraps a function to provide a type caster. Args: name (str): Name of the type caster (for nicer error messages) function (Callable[..., T]): Callable function for type caster. **kwargs (Any): Keyword arguments to pass to function. Returns: Callable[[str], T]: Type caster named partial function. \"\"\" # Create Partial Function and Set Name function = functools . partial ( function , ** kwargs ) setattr ( function , \"__name__\" , name ) # Return return function","title":"type_caster()"},{"location":"usage/commands/","text":"Commands ...","title":"Commands"},{"location":"usage/commands/#commands","text":"...","title":"Commands"},{"location":"usage/getting_started/","text":"Getting Started ...","title":"Getting Started"},{"location":"usage/getting_started/#getting-started","text":"...","title":"Getting Started"},{"location":"usage/models/","text":"Models ...","title":"Models"},{"location":"usage/models/#models","text":"...","title":"Models"},{"location":"usage/data_types/containers_mappings/","text":"Containers & Mappings ...","title":"Containers & Mappings"},{"location":"usage/data_types/containers_mappings/#containers-mappings","text":"...","title":"Containers &amp; Mappings"},{"location":"usage/data_types/enums_literals/","text":"Enums & Literals ...","title":"Enums & Literals"},{"location":"usage/data_types/enums_literals/#enums-literals","text":"...","title":"Enums &amp; Literals"},{"location":"usage/data_types/flags/","text":"Flags ...","title":"Flags"},{"location":"usage/data_types/flags/#flags","text":"...","title":"Flags"},{"location":"usage/data_types/standard/","text":"Standard ...","title":"Standard"},{"location":"usage/data_types/standard/#standard","text":"...","title":"Standard"}]}